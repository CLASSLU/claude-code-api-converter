name: Issue Review Bot

on:
  issues:
    types: [opened, edited]

jobs:
  issue-analysis:
    runs-on: ubuntu-latest
    name: Issue Analysis & Classification

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.9'

      - name: Install Dependencies
        run: |
          python -m pip install --upgrade pip
          pip install requests pyyaml

      - name: Analyze Issue
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          ISSUE_NUMBER: ${{ github.event.issue.number }}
          ISSUE_TITLE: ${{ github.event.issue.title }}
          ISSUE_BODY: ${{ github.event.issue.body }}
          ISSUE_AUTHOR: ${{ github.event.issue.user.login }}
        run: |
          python3 << 'EOF'
          import os
          import re
          import requests
          import json
          from typing import Dict, List

          class IssueAnalyzer:
              def __init__(self):
                  self.github_token = os.getenv('GITHUB_TOKEN')
                  self.issue_number = os.getenv('ISSUE_NUMBER')
                  self.title = os.getenv('ISSUE_TITLE', '')
                  self.body = os.getenv('ISSUE_BODY', '')
                  self.author = os.getenv('ISSUE_AUTHOR')
                  self.repo = os.getenv('GITHUB_REPOSITORY')

              def classify_issue_type(self) -> str:
                  title_lower = self.title.lower()
                  body_lower = self.body.lower()

                  if any(keyword in title_lower or keyword in body_lower for keyword in ['bug', 'error', 'exception', 'fail', 'crash']):
                      return 'bug'
                  elif any(keyword in title_lower or keyword in body_lower for keyword in ['feature', 'enhancement', 'improve', 'add', 'new']):
                      return 'feature'
                  elif any(keyword in title_lower or keyword in body_lower for keyword in ['doc', 'readme', 'documentation', 'manual']):
                      return 'documentation'
                  elif any(keyword in title_lower or keyword in body_lower for keyword in ['test', 'testing', 'unit test', 'pytest']):
                      return 'testing'
                  elif any(keyword in title_lower or keyword in body_lower for keyword in ['performance', 'slow', 'optimize', 'speed']):
                      return 'performance'
                  else:
                      return 'question'

              def extract_priority(self) -> str:
                  title_lower = self.title.lower()
                  body_lower = self.body.lower()

                  if any(keyword in title_lower or keyword in body_lower for keyword in ['urgent', 'critical', 'blocker']):
                      return 'high'
                  elif any(keyword in title_lower or keyword in body_lower for keyword in ['priority', 'important']):
                      return 'medium'
                  else:
                      return 'low'

              def extract_labels(self) -> List[str]:
                  issue_type = self.classify_issue_type()
                  priority = self.extract_priority()

                  labels = [issue_type, priority]

                  title_body = (self.title + ' ' + self.body).lower()
                  if 'claude code' in title_body or 'claude-code' in title_body:
                      labels.append('claude-code')
                  if 'api' in title_body:
                      labels.append('api')
                  if 'conversion' in title_body or 'convert' in title_body:
                      labels.append('conversion')

                  return labels

              def generate_triage_comment(self) -> str:
                  issue_type = self.classify_issue_type()
                  labels = self.extract_labels()
                  labels_str = ', '.join(labels)

                  if issue_type == 'bug':
                      comment = "## Issue Analysis Results\n\nType: Bug Report\nPriority: " + self.extract_priority().capitalize() + "\nSuggested Labels: " + labels_str + "\n\nPre-confirmation Checklist:\nPlease provide the following information to help troubleshoot the issue:\n\n- Environment (Python version, OS)\n- Detailed error information or stack trace\n- Minimal reproduction code or steps\n- Expected behavior description\n\nNext Steps: Please wait for the author to provide the above information. Once complete, maintainers will analyze the issue. For urgent issues, consider seeking community help in Discussions.\n\n---\n\nThis comment is automatically generated by Issue Review Bot"
                  elif issue_type == 'feature':
                      comment = "## Issue Analysis Results\n\nType: Feature Request\nPriority: " + self.extract_priority().capitalize() + "\nSuggested Labels: " + labels_str + "\n\nFeature Request Guidelines:\nTo better evaluate this feature request, please provide the following information:\n\n- Feature purpose and use case description\n- Expected API design or implementation approach\n- Relationship with existing functionality\n- Alternative solutions considered\n\nNext Steps: Community voting: Thumbs up for supporting this feature, thinking face for more discussion.\n\n---\n\nThis comment is automatically generated by Issue Review Bot"
                  else:
                      comment = "## Issue Analysis Results\n\nType: " + issue_type.capitalize() + "\nPriority: " + self.extract_priority().capitalize() + "\nSuggested Labels: " + labels_str + "\n\nHandling Suggestions:\nThis issue has been categorized as " + issue_type + ". Community members and maintainers will review it as soon as possible.\n\nNext Steps: Discussion: Waiting for community feedback or maintainer response.\n\n---\n\nThis comment is automatically generated by Issue Review Bot"

                  return comment

              def apply_labels(self, labels: List[str]):
                  url = f"https://api.github.com/repos/{self.repo}/issues/{self.issue_number}/labels"
                  headers = {
                      'Authorization': f'token {self.github_token}',
                      'Accept': 'application/vnd.github.v3+json',
                      'Content-Type': 'application/json'
                  }

                  existing_labels_resp = requests.get(url, headers=headers)
                  if existing_labels_resp.status_code == 200:
                      existing_labels = [label['name'] for label in existing_labels_resp.json()]
                      new_labels = [label for label in labels if label not in existing_labels]

                      if new_labels:
                          resp = requests.post(url, headers=headers, json={'labels': new_labels})
                          print(f"Applied labels: {new_labels}, Status: {resp.status_code}")

              def add_comment(self, comment: str):
                  url = f"https://api.github.com/repos/{self.repo}/issues/{self.issue_number}/comments"
                  headers = {
                      'Authorization': f'token {self.github_token}',
                      'Accept': 'application/vnd.github.v3+json',
                      'Content-Type': 'application/json'
                  }

                  resp = requests.post(url, headers=headers, json={'body': comment})
                  print(f"Added comment, Status: {resp.status_code}")

          analyzer = IssueAnalyzer()
          labels = analyzer.extract_labels()
          comment = analyzer.generate_triage_comment()

          print(f"Analysis complete. Labels: {labels}")
          analyzer.apply_labels(labels)
          analyzer.add_comment(comment)
          EOF

      - name: Notify Maintainers
        if: contains(github.event.issue.labels.*.name, 'bug') || contains(github.event.issue.labels.*.name, 'performance')
        uses: actions/github-script@v6
        with:
          script: |
            const issue = context.payload.issue;
            const message = `New ${issue.labels.find(l => ['bug', 'performance'].includes(l.name))?.name || 'important'} issue: "${issue.title}" by @${issue.user.login}`;

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: 1,
              body: message
            });